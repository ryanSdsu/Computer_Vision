from random import *
import numpy as np
from numpy import zeros
import os
from ComputerVision_Library import *

#Q1.2
#random permutations, shuffle the array
testList = [1,2,3,4,5,6,7,8,9,10]
shuffle(testList)
print(testList)

#Splice the array forward
testListTwo = [1,2,3,4,5,6,7,8,9,10]
testListSpliceByThree = testListTwo[0:11:3]
print(testListSpliceByThree)

#Find all the elements that are above 6
testListTwo = [1,2,3,4,5,6,7,8,9,10]
testListGreaterThanSix = [i for i in testListTwo if i > 6]
print(testListGreaterThanSix)

#Change all the values to 22 in a list
testListOneValues = np.empty(10)
testListOneValues.fill(1)
testListOneValues = list(map(int,testListOneValues))
testListOneValues = [i*22 for i in testListOneValues]

#Sum of the list
testListThree = [1,2,3,4,5,6,7,8,9,10]
sumOfListThree = sum(testListThree)
print(sumOfListThree)

#Splice the array backwards
testListFour = [1,2,3,4,5,6,7,8,9,10]
testListSpliceDecrement = testListFour[len(testListFour) :  : -1]
print(testListSpliceDecrement)


#Q3
#For part a, read in the image, grab all of the intensities in a 100X100 array (the intensities are between 0-255),
#from there place them in a one dimensional array, sort them in ascending order, and then plot them

#Part A
import numpy
import matplotlib.pyplot as plt
import random
import cv2

imageOne = cv2.imread('/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/test.png', 0)
imageOne = cv2.resize(imageOne, (100, 100))
imageOne_reshape = numpy.reshape(imageOne, (1, 100 * 100))
imageOne_sorted = numpy.sort(imageOne_reshape[0])
displayImage(imageOne_sorted, plt='plot')


#Part B
displayImage(imageOne_sorted, plt='hist', bin=32)

#Part C
threshold = 123
displayImage(imageOne, color='gray')


binaryImage = numpy.array(imageOne, copy=True)
for i in range(len(imageOne[0])):
    for j in range(len(imageOne)):
        if imageOne[i][j] > threshold:
            binaryImage[i][j] = 255
        else:
            binaryImage[i][j] = 0

displayImage(binaryImage, color='gray')


#Part D
mean_A = numpy.mean(imageOne_reshape)
image_mean = imageOne - mean_A
for i in range(len(image_mean[0])):
    for j in range(len(image_mean)):
        if image_mean[i][j] < 0:
            image_mean[i][j] = 0

displayImage(image_mean, color='gray')


#Part E
die_side = range(1,7)
roll = random.choice(die_side)
print("The random roll is: {}".format(roll))

#Part F
y = range(1,7)
z = map(list, zip(*[iter(y)]*3))
print(list(z))

#Part G
x = 9999
r = 0
c = 0
for i in range(len(imageOne)):
    for j in range(len(imageOne[0])):
        if imageOne[i][j] < x:
            x = imageOne[i][j]
            r = i
            c = j

print("min value: {} at {},{}".format(x, r, c))

#Part H
v = [1, 8 ,8 ,2, 1, 3, 9, 8]
v = set(v)
print(v)

#Part 2
"""
Go through the directory and get each of the images. 
Loop through them and maintain the averages via the RBG and the Grayscale compounding on top of each other. 
Store them globally and then output the avg of all the images once all the images have been reviewed. 
Do this for both the grayscale and the RGB. 

Tip: Use the looping over the directory from Kyles class to work this one out
"""

#Color Avg
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set1"
directory = os.fsencode(directoryInString)

totalAvg = 0
rAvg =  zeros((100,100))
gAvg =  zeros((100,100))
bAvg =  zeros((100,100))

numberOfFrames = 0
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rAvg[i][j] += rImage[i][j]

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gAvg[i][j] += gImage[i][j]

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bAvg[i][j] += bImage[i][j]

        numberOfFrames += 1
        continue

rAvg = rAvg / numberOfFrames
gAvg = gAvg / numberOfFrames
bAvg = bAvg / numberOfFrames

rAvg = rAvg.astype(np.uint8)
gAvg = gAvg.astype(np.uint8)
bAvg = bAvg.astype(np.uint8)

im3 = cv2.merge((rAvg,gAvg,bAvg))
displayImage(im3)



#Black and White Avg
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set1"
directory = os.fsencode(directoryInString)

totalAvg = 0
blackAndWhiteAvg =  zeros((100,100))

numberOfFrames = 0
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteAvg[i][j] += image[i][j]

        print(blackAndWhiteAvg)

        numberOfFrames += 1
        continue

blackAndWhiteAvg = blackAndWhiteAvg / numberOfFrames

blackAndWhiteAvg = blackAndWhiteAvg.astype(np.uint8)

displayImage(blackAndWhiteAvg, color='gray')



#https://stackoverflow.com/questions/25910050/perform-local-standard-deviation-in-python
#Standard Deviation, black and white

#First step is to make 2 frames (mean and std) that will hold everything and is the same size as the default images and N
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set1"
directory = os.fsencode(directoryInString)

numberOfFrames = 0
blackAndWhiteMean =  zeros((100,100))
blackAndWhiteStd =  zeros((100,100))


#The Next step is to populate one of the frames so that it has the mean of every single pixel added together
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteMean[i][j] += image[i][j]

        numberOfFrames += 1
        continue

blackAndWhiteMean = blackAndWhiteMean / numberOfFrames

#Then loop through every image again and at each pixel subtract the mean from the pixel, square it and add it to the other frame cummuatively
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteStd[i][j] = (image[i][j] - blackAndWhiteMean[i][j]) ** 2
        continue

#From there divide each pixel by N
blackAndWhiteStd = blackAndWhiteStd / numberOfFrames

#Build the image
blackAndWhiteStd = blackAndWhiteStd.astype(np.uint8)

print(blackAndWhiteStd)

print(blackAndWhiteStd.shape)
displayImage(blackAndWhiteStd, color='gray')


#https://stackoverflow.com/questions/25910050/perform-local-standard-deviation-in-python
#Standard Deviation, color


#Color Avg
#First step is to make 6 frames (mean and std) that will hold everything and is the same size as the default images and N
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set1"
directory = os.fsencode(directoryInString)

numberOfFrames = 0
rMean =  zeros((100,100))
gMean =  zeros((100,100))
bMean =  zeros((100,100))
rStd =  zeros((100,100))
gStd =  zeros((100,100))
bStd =  zeros((100,100))

#The Next step is to populate all 3 mean frames so that it has the mean of every single pixel added together
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rMean[i][j] += rImage[i][j]

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gMean[i][j] += gImage[i][j]

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bMean[i][j] += bImage[i][j]

        numberOfFrames += 1
        continue

rMean = rMean / numberOfFrames
gMean = gMean / numberOfFrames
bMean = bMean / numberOfFrames

#Then loop through every image again and at each pixel subtract the mean from the pixel, square it and add it to the other frame cummuatively
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rStd[i][j] = (rImage[i][j] - rMean[i][j]) ** 2

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gStd[i][j] = (gImage[i][j] - gMean[i][j]) ** 2

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bStd[i][j] = (bImage[i][j] - bMean[i][j]) ** 2

        continue


#From there divide each pixel by N
rStd = rStd / numberOfFrames
gStd = gStd / numberOfFrames
bStd = bStd / numberOfFrames

#Build the image
rStd = rStd.astype(np.uint8)
gStd = gStd.astype(np.uint8)
bStd = bStd.astype(np.uint8)

im3 = cv2.merge((rStd,gStd,bStd))
displayImage(im3)

"""
Go through the directory and get each of the images. 
Loop through them and maintain the averages via the RBG and the Grayscale compounding on top of each other. 
Store them globally and then output the avg of all the images once all the images have been reviewed. 
Do this for both the grayscale and the RGB. 

Tip: Use the looping over the directory from Kyles class to work this one out
"""

#Color Avg
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set2"
directory = os.fsencode(directoryInString)

totalAvg = 0
rAvg =  zeros((100,100))
gAvg =  zeros((100,100))
bAvg =  zeros((100,100))

numberOfFrames = 0
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rAvg[i][j] += rImage[i][j]

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gAvg[i][j] += gImage[i][j]

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bAvg[i][j] += bImage[i][j]

        numberOfFrames += 1
        continue

rAvg = rAvg / numberOfFrames
gAvg = gAvg / numberOfFrames
bAvg = bAvg / numberOfFrames

rAvg = rAvg.astype(np.uint8)
gAvg = gAvg.astype(np.uint8)
bAvg = bAvg.astype(np.uint8)

im3 = cv2.merge((rAvg,gAvg,bAvg))
displayImage(im3)



#Black and White Avg
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set2"
directory = os.fsencode(directoryInString)

totalAvg = 0
blackAndWhiteAvg =  zeros((100,100))

numberOfFrames = 0
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteAvg[i][j] += image[i][j]

        print(blackAndWhiteAvg)

        numberOfFrames += 1
        continue

blackAndWhiteAvg = blackAndWhiteAvg / numberOfFrames

blackAndWhiteAvg = blackAndWhiteAvg.astype(np.uint8)

displayImage(blackAndWhiteAvg, color='gray')



#https://stackoverflow.com/questions/25910050/perform-local-standard-deviation-in-python
#Standard Deviation, black and white

#First step is to make 2 frames (mean and std) that will hold everything and is the same size as the default images and N
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set2"
directory = os.fsencode(directoryInString)

numberOfFrames = 0
blackAndWhiteMean =  zeros((100,100))
blackAndWhiteStd =  zeros((100,100))


#The Next step is to populate one of the frames so that it has the mean of every single pixel added together
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteMean[i][j] += image[i][j]

        numberOfFrames += 1
        continue

blackAndWhiteMean = blackAndWhiteMean / numberOfFrames

#Then loop through every image again and at each pixel subtract the mean from the pixel, square it and add it to the other frame cummuatively
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        image = cv2.resize(image, (100,100))

        for i in range(len(image[0])):
            for j in range(len(image)):
                blackAndWhiteStd[i][j] = (image[i][j] - blackAndWhiteMean[i][j]) ** 2
        continue

#From there divide each pixel by N
blackAndWhiteStd = blackAndWhiteStd / numberOfFrames

#Build the image
blackAndWhiteStd = blackAndWhiteStd.astype(np.uint8)

print(blackAndWhiteStd)

print(blackAndWhiteStd.shape)
displayImage(blackAndWhiteStd, color='gray')


#https://stackoverflow.com/questions/25910050/perform-local-standard-deviation-in-python
#Standard Deviation, color


#Color Avg
#First step is to make 6 frames (mean and std) that will hold everything and is the same size as the default images and N
directoryInString ="/Users/RJ/PycharmProjects/Computer_Vision/Homework_One/set2"
directory = os.fsencode(directoryInString)

numberOfFrames = 0
rMean =  zeros((100,100))
gMean =  zeros((100,100))
bMean =  zeros((100,100))
rStd =  zeros((100,100))
gStd =  zeros((100,100))
bStd =  zeros((100,100))

#The Next step is to populate all 3 mean frames so that it has the mean of every single pixel added together
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rMean[i][j] += rImage[i][j]

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gMean[i][j] += gImage[i][j]

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bMean[i][j] += bImage[i][j]

        numberOfFrames += 1
        continue

rMean = rMean / numberOfFrames
gMean = gMean / numberOfFrames
bMean = bMean / numberOfFrames

#Then loop through every image again and at each pixel subtract the mean from the pixel, square it and add it to the other frame cummuatively
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith(".jpg"):
        filename = directoryInString + "/" + filename
        image = cv2.imread(filename)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        image = cv2.resize(image, (100,100))

        rImage = image[:,:,0]
        gImage = image[:,:,1]
        bImage = image[:,:,2]

        for i in range(len(rImage[0])):
            for j in range(len(rImage)):
                rStd[i][j] = (rImage[i][j] - rMean[i][j]) ** 2

        for i in range(len(gImage[0])):
            for j in range(len(gImage)):
                gStd[i][j] = (gImage[i][j] - gMean[i][j]) ** 2

        for i in range(len(bImage[0])):
            for j in range(len(bImage)):
                bStd[i][j] = (bImage[i][j] - bMean[i][j]) ** 2

        continue


#From there divide each pixel by N
rStd = rStd / numberOfFrames
gStd = gStd / numberOfFrames
bStd = bStd / numberOfFrames

#Build the image
rStd = rStd.astype(np.uint8)
gStd = gStd.astype(np.uint8)
bStd = bStd.astype(np.uint8)

im3 = cv2.merge((rStd,gStd,bStd))
displayImage(im3)
